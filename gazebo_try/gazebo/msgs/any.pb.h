// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: any.proto

#ifndef PROTOBUF_any_2eproto__INCLUDED
#define PROTOBUF_any_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>


#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "color.pb.h"
#include "pose.pb.h"
#include "quaternion.pb.h"
#include "time.pb.h"
#include "vector3d.pb.h"
#pragma GCC system_header
#include <boost/shared_ptr.hpp>
#include <gazebo/util/system.hh>
#include "gazebo/msgs/MsgFactory.hh"
// @@protoc_insertion_point(includes)

namespace gazebo {
namespace msgs {

// Internal implementation detail -- do not call these.
void GZ_MSGS_VISIBLE protobuf_AddDesc_any_2eproto();
void protobuf_AssignDesc_any_2eproto();
void protobuf_ShutdownFile_any_2eproto();

class Any;

enum Any_ValueType {
  Any_ValueType_NONE = 1,
  Any_ValueType_DOUBLE = 2,
  Any_ValueType_INT32 = 3,
  Any_ValueType_STRING = 4,
  Any_ValueType_BOOLEAN = 5,
  Any_ValueType_VECTOR3D = 6,
  Any_ValueType_COLOR = 7,
  Any_ValueType_POSE3D = 8,
  Any_ValueType_QUATERNIOND = 9,
  Any_ValueType_TIME = 10
};
GZ_MSGS_VISIBLE bool Any_ValueType_IsValid(int value);
const Any_ValueType Any_ValueType_ValueType_MIN = Any_ValueType_NONE;
const Any_ValueType Any_ValueType_ValueType_MAX = Any_ValueType_TIME;
const int Any_ValueType_ValueType_ARRAYSIZE = Any_ValueType_ValueType_MAX + 1;

GZ_MSGS_VISIBLE const ::google::protobuf::EnumDescriptor* Any_ValueType_descriptor();
inline const ::std::string& Any_ValueType_Name(Any_ValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Any_ValueType_descriptor(), value);
}
inline bool Any_ValueType_Parse(
    const ::std::string& name, Any_ValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Any_ValueType>(
    Any_ValueType_descriptor(), name, value);
}
// ===================================================================

class GZ_MSGS_VISIBLE Any : public ::google::protobuf::Message {
 public:
  Any();
  virtual ~Any();

  Any(const Any& from);

  inline Any& operator=(const Any& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Any& default_instance();

  void Swap(Any* other);

  // implements Message ----------------------------------------------

  Any* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Any& from);
  void MergeFrom(const Any& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Any_ValueType ValueType;
  static const ValueType NONE = Any_ValueType_NONE;
  static const ValueType DOUBLE = Any_ValueType_DOUBLE;
  static const ValueType INT32 = Any_ValueType_INT32;
  static const ValueType STRING = Any_ValueType_STRING;
  static const ValueType BOOLEAN = Any_ValueType_BOOLEAN;
  static const ValueType VECTOR3D = Any_ValueType_VECTOR3D;
  static const ValueType COLOR = Any_ValueType_COLOR;
  static const ValueType POSE3D = Any_ValueType_POSE3D;
  static const ValueType QUATERNIOND = Any_ValueType_QUATERNIOND;
  static const ValueType TIME = Any_ValueType_TIME;
  static inline bool ValueType_IsValid(int value) {
    return Any_ValueType_IsValid(value);
  }
  static const ValueType ValueType_MIN =
    Any_ValueType_ValueType_MIN;
  static const ValueType ValueType_MAX =
    Any_ValueType_ValueType_MAX;
  static const int ValueType_ARRAYSIZE =
    Any_ValueType_ValueType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ValueType_descriptor() {
    return Any_ValueType_descriptor();
  }
  static inline const ::std::string& ValueType_Name(ValueType value) {
    return Any_ValueType_Name(value);
  }
  static inline bool ValueType_Parse(const ::std::string& name,
      ValueType* value) {
    return Any_ValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .gazebo.msgs.Any.ValueType type = 1 [default = NONE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::gazebo::msgs::Any_ValueType type() const;
  inline void set_type(::gazebo::msgs::Any_ValueType value);

  // optional double double_value = 2;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 2;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional int32 int_value = 3;
  inline bool has_int_value() const;
  inline void clear_int_value();
  static const int kIntValueFieldNumber = 3;
  inline ::google::protobuf::int32 int_value() const;
  inline void set_int_value(::google::protobuf::int32 value);

  // optional string string_value = 4;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 4;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional bool bool_value = 5;
  inline bool has_bool_value() const;
  inline void clear_bool_value();
  static const int kBoolValueFieldNumber = 5;
  inline bool bool_value() const;
  inline void set_bool_value(bool value);

  // optional .gazebo.msgs.Vector3d vector3d_value = 6;
  inline bool has_vector3d_value() const;
  inline void clear_vector3d_value();
  static const int kVector3DValueFieldNumber = 6;
  inline const ::gazebo::msgs::Vector3d& vector3d_value() const;
  inline ::gazebo::msgs::Vector3d* mutable_vector3d_value();
  inline ::gazebo::msgs::Vector3d* release_vector3d_value();
  inline void set_allocated_vector3d_value(::gazebo::msgs::Vector3d* vector3d_value);

  // optional .gazebo.msgs.Color color_value = 7;
  inline bool has_color_value() const;
  inline void clear_color_value();
  static const int kColorValueFieldNumber = 7;
  inline const ::gazebo::msgs::Color& color_value() const;
  inline ::gazebo::msgs::Color* mutable_color_value();
  inline ::gazebo::msgs::Color* release_color_value();
  inline void set_allocated_color_value(::gazebo::msgs::Color* color_value);

  // optional .gazebo.msgs.Pose pose3d_value = 8;
  inline bool has_pose3d_value() const;
  inline void clear_pose3d_value();
  static const int kPose3DValueFieldNumber = 8;
  inline const ::gazebo::msgs::Pose& pose3d_value() const;
  inline ::gazebo::msgs::Pose* mutable_pose3d_value();
  inline ::gazebo::msgs::Pose* release_pose3d_value();
  inline void set_allocated_pose3d_value(::gazebo::msgs::Pose* pose3d_value);

  // optional .gazebo.msgs.Quaternion quaternion_value = 9;
  inline bool has_quaternion_value() const;
  inline void clear_quaternion_value();
  static const int kQuaternionValueFieldNumber = 9;
  inline const ::gazebo::msgs::Quaternion& quaternion_value() const;
  inline ::gazebo::msgs::Quaternion* mutable_quaternion_value();
  inline ::gazebo::msgs::Quaternion* release_quaternion_value();
  inline void set_allocated_quaternion_value(::gazebo::msgs::Quaternion* quaternion_value);

  // optional .gazebo.msgs.Time time_value = 10;
  inline bool has_time_value() const;
  inline void clear_time_value();
  static const int kTimeValueFieldNumber = 10;
  inline const ::gazebo::msgs::Time& time_value() const;
  inline ::gazebo::msgs::Time* mutable_time_value();
  inline ::gazebo::msgs::Time* release_time_value();
  inline void set_allocated_time_value(::gazebo::msgs::Time* time_value);

  // @@protoc_insertion_point(class_scope:gazebo.msgs.Any)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_int_value();
  inline void clear_has_int_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_bool_value();
  inline void clear_has_bool_value();
  inline void set_has_vector3d_value();
  inline void clear_has_vector3d_value();
  inline void set_has_color_value();
  inline void clear_has_color_value();
  inline void set_has_pose3d_value();
  inline void clear_has_pose3d_value();
  inline void set_has_quaternion_value();
  inline void clear_has_quaternion_value();
  inline void set_has_time_value();
  inline void clear_has_time_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double double_value_;
  int type_;
  ::google::protobuf::int32 int_value_;
  ::std::string* string_value_;
  ::gazebo::msgs::Vector3d* vector3d_value_;
  ::gazebo::msgs::Color* color_value_;
  ::gazebo::msgs::Pose* pose3d_value_;
  ::gazebo::msgs::Quaternion* quaternion_value_;
  ::gazebo::msgs::Time* time_value_;
  bool bool_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void GZ_MSGS_VISIBLE protobuf_AddDesc_any_2eproto();
  friend void protobuf_AssignDesc_any_2eproto();
  friend void protobuf_ShutdownFile_any_2eproto();

  void InitAsDefaultInstance();
  static Any* default_instance_;
};
// ===================================================================


// ===================================================================

// Any

// required .gazebo.msgs.Any.ValueType type = 1 [default = NONE];
inline bool Any::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Any::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Any::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Any::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::gazebo::msgs::Any_ValueType Any::type() const {
  return static_cast< ::gazebo::msgs::Any_ValueType >(type_);
}
inline void Any::set_type(::gazebo::msgs::Any_ValueType value) {
  assert(::gazebo::msgs::Any_ValueType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double double_value = 2;
inline bool Any::has_double_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Any::set_has_double_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Any::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Any::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double Any::double_value() const {
  return double_value_;
}
inline void Any::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
}

// optional int32 int_value = 3;
inline bool Any::has_int_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Any::set_has_int_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Any::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Any::clear_int_value() {
  int_value_ = 0;
  clear_has_int_value();
}
inline ::google::protobuf::int32 Any::int_value() const {
  return int_value_;
}
inline void Any::set_int_value(::google::protobuf::int32 value) {
  set_has_int_value();
  int_value_ = value;
}

// optional string string_value = 4;
inline bool Any::has_string_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Any::set_has_string_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Any::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Any::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& Any::string_value() const {
  return *string_value_;
}
inline void Any::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void Any::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void Any::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Any::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* Any::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Any::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::kEmptyString) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool bool_value = 5;
inline bool Any::has_bool_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Any::set_has_bool_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Any::clear_has_bool_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Any::clear_bool_value() {
  bool_value_ = false;
  clear_has_bool_value();
}
inline bool Any::bool_value() const {
  return bool_value_;
}
inline void Any::set_bool_value(bool value) {
  set_has_bool_value();
  bool_value_ = value;
}

// optional .gazebo.msgs.Vector3d vector3d_value = 6;
inline bool Any::has_vector3d_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Any::set_has_vector3d_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Any::clear_has_vector3d_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Any::clear_vector3d_value() {
  if (vector3d_value_ != NULL) vector3d_value_->::gazebo::msgs::Vector3d::Clear();
  clear_has_vector3d_value();
}
inline const ::gazebo::msgs::Vector3d& Any::vector3d_value() const {
  return vector3d_value_ != NULL ? *vector3d_value_ : *default_instance_->vector3d_value_;
}
inline ::gazebo::msgs::Vector3d* Any::mutable_vector3d_value() {
  set_has_vector3d_value();
  if (vector3d_value_ == NULL) vector3d_value_ = new ::gazebo::msgs::Vector3d;
  return vector3d_value_;
}
inline ::gazebo::msgs::Vector3d* Any::release_vector3d_value() {
  clear_has_vector3d_value();
  ::gazebo::msgs::Vector3d* temp = vector3d_value_;
  vector3d_value_ = NULL;
  return temp;
}
inline void Any::set_allocated_vector3d_value(::gazebo::msgs::Vector3d* vector3d_value) {
  delete vector3d_value_;
  vector3d_value_ = vector3d_value;
  if (vector3d_value) {
    set_has_vector3d_value();
  } else {
    clear_has_vector3d_value();
  }
}

// optional .gazebo.msgs.Color color_value = 7;
inline bool Any::has_color_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Any::set_has_color_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Any::clear_has_color_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Any::clear_color_value() {
  if (color_value_ != NULL) color_value_->::gazebo::msgs::Color::Clear();
  clear_has_color_value();
}
inline const ::gazebo::msgs::Color& Any::color_value() const {
  return color_value_ != NULL ? *color_value_ : *default_instance_->color_value_;
}
inline ::gazebo::msgs::Color* Any::mutable_color_value() {
  set_has_color_value();
  if (color_value_ == NULL) color_value_ = new ::gazebo::msgs::Color;
  return color_value_;
}
inline ::gazebo::msgs::Color* Any::release_color_value() {
  clear_has_color_value();
  ::gazebo::msgs::Color* temp = color_value_;
  color_value_ = NULL;
  return temp;
}
inline void Any::set_allocated_color_value(::gazebo::msgs::Color* color_value) {
  delete color_value_;
  color_value_ = color_value;
  if (color_value) {
    set_has_color_value();
  } else {
    clear_has_color_value();
  }
}

// optional .gazebo.msgs.Pose pose3d_value = 8;
inline bool Any::has_pose3d_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Any::set_has_pose3d_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Any::clear_has_pose3d_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Any::clear_pose3d_value() {
  if (pose3d_value_ != NULL) pose3d_value_->::gazebo::msgs::Pose::Clear();
  clear_has_pose3d_value();
}
inline const ::gazebo::msgs::Pose& Any::pose3d_value() const {
  return pose3d_value_ != NULL ? *pose3d_value_ : *default_instance_->pose3d_value_;
}
inline ::gazebo::msgs::Pose* Any::mutable_pose3d_value() {
  set_has_pose3d_value();
  if (pose3d_value_ == NULL) pose3d_value_ = new ::gazebo::msgs::Pose;
  return pose3d_value_;
}
inline ::gazebo::msgs::Pose* Any::release_pose3d_value() {
  clear_has_pose3d_value();
  ::gazebo::msgs::Pose* temp = pose3d_value_;
  pose3d_value_ = NULL;
  return temp;
}
inline void Any::set_allocated_pose3d_value(::gazebo::msgs::Pose* pose3d_value) {
  delete pose3d_value_;
  pose3d_value_ = pose3d_value;
  if (pose3d_value) {
    set_has_pose3d_value();
  } else {
    clear_has_pose3d_value();
  }
}

// optional .gazebo.msgs.Quaternion quaternion_value = 9;
inline bool Any::has_quaternion_value() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Any::set_has_quaternion_value() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Any::clear_has_quaternion_value() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Any::clear_quaternion_value() {
  if (quaternion_value_ != NULL) quaternion_value_->::gazebo::msgs::Quaternion::Clear();
  clear_has_quaternion_value();
}
inline const ::gazebo::msgs::Quaternion& Any::quaternion_value() const {
  return quaternion_value_ != NULL ? *quaternion_value_ : *default_instance_->quaternion_value_;
}
inline ::gazebo::msgs::Quaternion* Any::mutable_quaternion_value() {
  set_has_quaternion_value();
  if (quaternion_value_ == NULL) quaternion_value_ = new ::gazebo::msgs::Quaternion;
  return quaternion_value_;
}
inline ::gazebo::msgs::Quaternion* Any::release_quaternion_value() {
  clear_has_quaternion_value();
  ::gazebo::msgs::Quaternion* temp = quaternion_value_;
  quaternion_value_ = NULL;
  return temp;
}
inline void Any::set_allocated_quaternion_value(::gazebo::msgs::Quaternion* quaternion_value) {
  delete quaternion_value_;
  quaternion_value_ = quaternion_value;
  if (quaternion_value) {
    set_has_quaternion_value();
  } else {
    clear_has_quaternion_value();
  }
}

// optional .gazebo.msgs.Time time_value = 10;
inline bool Any::has_time_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Any::set_has_time_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Any::clear_has_time_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Any::clear_time_value() {
  if (time_value_ != NULL) time_value_->::gazebo::msgs::Time::Clear();
  clear_has_time_value();
}
inline const ::gazebo::msgs::Time& Any::time_value() const {
  return time_value_ != NULL ? *time_value_ : *default_instance_->time_value_;
}
inline ::gazebo::msgs::Time* Any::mutable_time_value() {
  set_has_time_value();
  if (time_value_ == NULL) time_value_ = new ::gazebo::msgs::Time;
  return time_value_;
}
inline ::gazebo::msgs::Time* Any::release_time_value() {
  clear_has_time_value();
  ::gazebo::msgs::Time* temp = time_value_;
  time_value_ = NULL;
  return temp;
}
inline void Any::set_allocated_time_value(::gazebo::msgs::Time* time_value) {
  delete time_value_;
  time_value_ = time_value;
  if (time_value) {
    set_has_time_value();
  } else {
    clear_has_time_value();
  }
}


typedef boost::shared_ptr<gazebo::msgs::Any> AnyPtr;
// @@protoc_insertion_point(namespace_scope)

}  // namespace msgs
}  // namespace gazebo

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gazebo::msgs::Any_ValueType>() {
  return ::gazebo::msgs::Any_ValueType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

typedef const boost::shared_ptr<gazebo::msgs::Any const> ConstAnyPtr;
// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_any_2eproto__INCLUDED
